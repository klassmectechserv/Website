import { PageCollectionItemBase, Collection } from '@nuxt/content';
import { z, TypeOf } from 'zod';

declare global {
    var __sitemapCollectionFilters: Map<string, (entry: any) => boolean> | undefined;
    var __sitemapCollectionOnUrlFns: Map<string, (url: any, entry: any, collection: string) => void> | undefined;
}
declare const schema: z.ZodObject<{
    sitemap: z.ZodOptional<z.ZodObject<{
        loc: z.ZodOptional<z.ZodString>;
        lastmod: z.ZodOptional<z.ZodDate>;
        changefreq: z.ZodOptional<z.ZodUnion<readonly [z.ZodLiteral<"always">, z.ZodLiteral<"hourly">, z.ZodLiteral<"daily">, z.ZodLiteral<"weekly">, z.ZodLiteral<"monthly">, z.ZodLiteral<"yearly">, z.ZodLiteral<"never">]>>;
        priority: z.ZodOptional<z.ZodNumber>;
        images: z.ZodOptional<z.ZodArray<z.ZodObject<{
            loc: z.ZodString;
            caption: z.ZodOptional<z.ZodString>;
            geo_location: z.ZodOptional<z.ZodString>;
            title: z.ZodOptional<z.ZodString>;
            license: z.ZodOptional<z.ZodString>;
        }, z.core.$strip>>>;
        videos: z.ZodOptional<z.ZodArray<z.ZodObject<{
            content_loc: z.ZodString;
            player_loc: z.ZodOptional<z.ZodString>;
            duration: z.ZodOptional<z.ZodString>;
            expiration_date: z.ZodOptional<z.ZodDate>;
            rating: z.ZodOptional<z.ZodNumber>;
            view_count: z.ZodOptional<z.ZodNumber>;
            publication_date: z.ZodOptional<z.ZodDate>;
            family_friendly: z.ZodOptional<z.ZodBoolean>;
            tag: z.ZodOptional<z.ZodString>;
            category: z.ZodOptional<z.ZodString>;
            restriction: z.ZodOptional<z.ZodObject<{
                relationship: z.ZodOptional<z.ZodLiteral<"allow">>;
                value: z.ZodOptional<z.ZodString>;
            }, z.core.$strip>>;
            gallery_loc: z.ZodOptional<z.ZodString>;
            price: z.ZodOptional<z.ZodString>;
            requires_subscription: z.ZodOptional<z.ZodBoolean>;
            uploader: z.ZodOptional<z.ZodString>;
        }, z.core.$strip>>>;
    }, z.core.$strip>>;
}, z.core.$strip>;
type SitemapSchema = TypeOf<typeof schema>;
interface AsSitemapCollectionOptions<TEntry = Record<string, unknown>> {
    /**
     * Collection name. Must match the key in your collections object.
     * Required when using `filter` or `onUrl`.
     * @example
     * collections: {
     *   blog: defineCollection(asSitemapCollection({...}, { name: 'blog', filter: ... }))
     * }
     */
    name?: string;
    /**
     * Runtime filter function to exclude entries from sitemap.
     * Receives the full content entry including all schema fields.
     * Requires `name` parameter to be set.
     * @example
     * { name: 'blog', filter: (entry) => !entry.draft && new Date(entry.date) <= new Date() }
     */
    filter?: (entry: PageCollectionItemBase & SitemapSchema & TEntry) => boolean;
    /**
     * Transform the sitemap URL entry for each item in this collection.
     * Mutate `url` directly to change `loc`, `lastmod`, `priority`, etc.
     * The full content entry and collection name are provided for context.
     * Useful when the collection uses `prefix: ''` in its source config,
     * which strips the directory prefix from content paths.
     * Requires `name` parameter to be set.
     * @example
     * // Add a locale prefix
     * { name: 'content_zh', onUrl: (url) => { url.loc = `/zh${url.loc}` } }
     * @example
     * // Use content entry fields to set priority
     * { name: 'blog', onUrl: (url, entry) => { url.priority = entry.featured ? 1.0 : 0.5 } }
     */
    onUrl?: (url: {
        loc: string;
        lastmod?: string | Date;
        changefreq?: string;
        priority?: number;
        images?: {
            loc: string;
        }[];
        videos?: {
            content_loc: string;
        }[];
        [key: string]: unknown;
    }, entry: PageCollectionItemBase & SitemapSchema & TEntry, collection: string) => void;
}
declare function asSitemapCollection<T>(collection: Collection<T>, options?: AsSitemapCollectionOptions<T>): Collection<T>;

export { asSitemapCollection, schema };
export type { AsSitemapCollectionOptions, SitemapSchema };
